function [ sum_sk ] = LP_OoSE_run(trainingCellShapeData, OoSE_frames, path_to_LPtrained, new_unique_savedestination )
%LAPLACIANPYRAMIDS_OOSE Summary of this function goes here
%   Detailed explanation goes here
%trainingCellShapeData should be the output of BAM DM through the
%ShapeManifoldEmbedding code of your training data.

%OoSE_frames should be your segmented cells from your out of sample data
%set, this is called BigCellArray and can found Bigcellarrayandindex.mat in
%your contour output folder from 1-ImageSegmentationFull

%LP_OoSE_train should be run before this one, path_to_LPtrained should be
%the path to its output

%new_unique_savedestination should be a path to a chosen folder. N.b. any
%repeated runs of this code to the the same destination will over-write
%previous runs.
%

N=length(OoSE_frames);
%waitbar
h = waitbar(0,'Please wait...');
waitbar(0,h,sprintf('%5.2f%% completed ..',0));

for i=1:N
    OoSE_frames{i}=clockcheck(OoSE_frames{i});
end

nodes=512; %This selects the number of vertices for the contours, BAM runs quicker if it's a power of 2.
for i=1:N
    CSD.point(i).coords=OoSE_frames{i};
end
%%interpolation
%stack={CellShapeData.point.coords}';
[snakematrix, lengthvec ]=Interpolate_and_rescale(OoSE_frames,h,nodes); 
for i=1:N
    CSD.point(i).coords_interp=snakematrix(:,i);
    CSD.point(i).original_curve_length=lengthvec(i);
end

%translate shapes to origin
for i=1:N
    f=CSD.point(i).coords_interp;
    Xf=f(1:nodes);
    Yf=f((nodes+1):end);
    cXf=mean(Xf);
    cYf=mean(Yf);
    CSD.point(i).coords_interp_trans=[(Xf-cXf) ; (Yf-cYf)];
end

%convert to complex representation
for i=1:N
    compvec_temp=CSD.point(i).coords_interp_trans(1:nodes) + 1i*CSD.point(i).coords_interp_trans((nodes+1):end);
    CSD.point(i).coords_comp = compvec_temp(:);
end
    
%diffusion map embedding
%new_d=5; %Increase this to generate more new dimensions

for i=1:N
    curve=CSD.point(i).coords_comp;
    CSD.point(i).sum_curve = sum(real(curve).^2+imag(curve).^2);
    CSD.point(i).fft_conj=fft(conj(curve));
    CSD.point(i).fft_flip=fft(flipud(curve));
end

dd=zeros(N,1);
train_nobs=length(trainingCellShapeData.point);
D=zeros(train_nobs,N);
kk=1;
for i=1:train_nobs
    
    for j=1:N
        D(i,j)=BAM(CSD.point(j).sum_curve,trainingCellShapeData.point(i).sum_curve,CSD.point(j).fft_conj,trainingCellShapeData.point(i).fft_flip);
        
    end
    waitbar(j/train_nobs,h,sprintf('OoSE Step 2. Computing distances: %5.2f%% completed ..',j/train_nobs));
    
end
waitbar(1,h,'OoSE Step 3. Embedding, please wait.');
load(path_to_LPtrained);
ndims=length(d);

%train_nobs=length(D);
sum_sk=zeros(N,ndims);
filedir = fullfile(new_unique_savedestination, 'Dist_mat.mat');
save(filedir, 'D','-v7.3');

D=D./(sqrt(nodes));
dd=dd./(sqrt(nodes));
sig_sq=median(dd);


D=D.^2;
D=D/(2*sig_sq);
for n=1:N
    for m=1:ndims
        K=length(d{m});
        for i=1:K
            k=zeros(1,train_nobs);
            sig=sig_naught/(2^(i-1));
            
            D2=D(:,n)./sig;
            D2=-D2;
            D2=exp(D2);
            for j=1:train_nobs
                k(j)=D2(j)/q{m}{i}(j);          
            end
            sum_sk(n,m)=sum_sk(n,m)+k*d{m}{i}';
        end
    end
end

OoSE_emb=sum_sk;

save([new_unique_savedestination '/OoSE_embedding.mat'], 'OoSE_emb','-v7.3');
h=waitbar(1,h,'Complete');
delete(h);

end




